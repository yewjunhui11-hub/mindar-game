<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, user-scalable=no" />
  <title>Reduce Single-Use Plastic AR Game</title>

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <!-- nicer font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700;800&display=swap" rel="stylesheet">

  <style>
    body { margin:0; overflow:hidden; font-family: Inter, system-ui, -apple-system, Segoe UI, Arial; }
    canvas, a-scene { touch-action: none; }

    #hud{
      position:fixed; top:12px; left:12px; right:12px;
      display:flex; justify-content:space-between;
      z-index:10; color:#fff; font-weight:800;
      text-shadow:0 2px 10px rgba(0,0,0,0.85);
      pointer-events:none;
      font-size:18px;
    }

    .overlay{
      position:fixed; inset:0; z-index:20;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.65);
      padding:18px;
    }
    .card{
      width:min(560px, 92vw);
      background:rgba(18,18,18,0.92);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:18px;
      padding:16px;
      color:#fff;
      box-shadow:0 18px 45px rgba(0,0,0,0.5);
    }
    h2{ margin:0 0 10px 0; font-size:22px; letter-spacing:-0.2px; }
    p{ margin:0 0 10px 0; line-height:1.45; opacity:0.95; }
    ul{ margin:10px 0 14px 18px; padding:0; line-height:1.55; }
    li{ margin:6px 0; }
    .row{ display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    button{
      padding:12px 14px; border-radius:12px; border:0;
      font-weight:800; cursor:pointer; font-family:inherit;
      background:#fff; color:#111;
    }
    .small{ opacity:0.72; font-size:12px; }
  </style>
</head>

<body>
  <!-- HUD -->
  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Time: <span id="time">30</span>s</div>
  </div>

  <!-- Instruction Overlay (shown after first scan) -->
  <div id="introOverlay" class="overlay" style="display:none;">
    <div class="card">
      <h2>Stop Single-Use Plastic!!</h2>
      <p id="scanStatus" class="small">Scan the target image to beginâ€¦</p>
      <ul>
        <li>You have <b>30 seconds</b>.</li>
        <li>Tap <b>reusable</b> items to get <b>+1</b>.</li>
        <li>Careful not to tap on <b>single-use plastic</b> items or, <b>âˆ’1</b>.</li>
        <li>Good Luck!</li>
      </ul>
      <div class="row">
        <span class="small">Ready?</span>
        <button id="startBtn">Start</button>
      </div>
      <div class="small" style="margin-top:10px;">
        Tip: coming closer helps tracking.
      </div>
    </div>
  </div>

  <!-- End Overlay -->
  <div id="endOverlay" class="overlay" style="display:none;">
    <div class="card">
      <h2>Congrats ðŸŽ‰</h2>
      <p>Your points awarded: <b><span id="finalScore">0</span></b></p>
      <div class="row">
        <span class="small">Play again?</span>
        <button id="againBtn">Again</button>
      </div>
    </div>
  </div>

  <a-scene
    mindar-image="imageTargetSrc: targets.mind; autoStart: true;"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: true"
    renderer="colorManagement: true; physicallyCorrectLights: true"
  >
    <a-assets>
      <a-asset-item id="c1" src="correct_1.glb"></a-asset-item>
      <a-asset-item id="c2" src="correct_2.glb"></a-asset-item>
      <a-asset-item id="c3" src="correct_3.glb"></a-asset-item>

      <a-asset-item id="w1" src="wrong_1.glb"></a-asset-item>
      <a-asset-item id="w2" src="wrong_2.glb"></a-asset-item>
      <a-asset-item id="w3" src="wrong_3.glb"></a-asset-item>
    </a-assets>

    <a-camera id="cam" position="0 0 0" look-controls="enabled: false"></a-camera>

    <!-- Anchor -->
    <a-entity id="anchor" mindar-image-target="targetIndex: 0"></a-entity>
  </a-scene>

  <script>
    // ---------------- CONFIG ----------------
    const GAME_SECONDS = 30;
    const MAX_ON_SCREEN = 4;

    // spawn area (relative to target); tweak if needed
    const SPAWN_X = 0.65;
    const SPAWN_Y = 0.38;
    const Z = 0.05;

    // Minimum distance between spawned models (increase if still overlapping)
    const MIN_DISTANCE = 0.25;

    // Per-model scale (TUNE THESE so all look similar size)
    // Start with same values, then adjust per model.
    const SCALE_BY_ID = {
      "#c1": "0.05 0.05 0.05",
      "#c2": "0.25 0.25 0.25",
      "#c3": "0.25 0.25 0.25",
      "#w1": "0.55 0.55 0.55",
      "#w2": "0.55 0.55 0.55",
      "#w3": "0.55 0.55 0.55",
    };

    const MODEL_POOL = [
      { id: "#c1", type: "correct" },
      { id: "#c2", type: "correct" },
      { id: "#c3", type: "correct" },
      { id: "#w1", type: "wrong"   },
      { id: "#w2", type: "wrong"   },
      { id: "#w3", type: "wrong"   },
    ];

    // ---------------- STATE ----------------
    const sceneEl = document.querySelector("a-scene");
    const anchorEl = document.getElementById("anchor");

    const introOverlay = document.getElementById("introOverlay");
    const endOverlay = document.getElementById("endOverlay");
    const startBtn = document.getElementById("startBtn");
    const againBtn = document.getElementById("againBtn");

    const scanStatus = document.getElementById("scanStatus");
    const scoreEl = document.getElementById("score");
    const timeEl = document.getElementById("time");
    const finalScoreEl = document.getElementById("finalScore");

    let scannedOnce = false;   // first time targetFound happens
    let running = false;
    let score = 0;
    let timeLeft = GAME_SECONDS;
    let timerId = null;

    // manual raycast for reliable tapping
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    let tapLock = false;

    function rand(min, max){ return Math.random() * (max - min) + min; }
    function lockTapBriefly(){
      tapLock = true;
      setTimeout(() => tapLock = false, 220);
    }
    function updateHud(){
      scoreEl.textContent = score;
      timeEl.textContent = timeLeft;
    }

    function clearModels(){
      anchorEl.querySelectorAll(".spawned").forEach(el => el.remove());
    }

    // ---------- MODEL PICKERS ----------
    function pickRandomFrom(list){
      return list[Math.floor(Math.random() * list.length)];
    }
    function pickRandomCorrect(){
      return pickRandomFrom(MODEL_POOL.filter(m => m.type === "correct"));
    }
    function pickRandomAny(){
      return pickRandomFrom(MODEL_POOL);
    }

    // ---------- SPACING HELPERS ----------
    function getSpawnedPositions(){
      return Array.from(anchorEl.querySelectorAll(".spawned")).map(el => {
        const p = el.getAttribute("position");
        return { x: parseFloat(p.x), y: parseFloat(p.y) };
      });
    }

    function distance(a, b){
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function findNonOverlappingPosition(){
      const existing = getSpawnedPositions();
      let best = { x: 0, y: 0 };

      for (let attempt = 0; attempt < 25; attempt++){
        const candidate = { x: rand(-SPAWN_X, SPAWN_X), y: rand(-SPAWN_Y, SPAWN_Y) };
        best = candidate;

        const ok = existing.every(p => distance(candidate, p) >= MIN_DISTANCE);
        if (ok) return candidate;
      }
      // fallback if space is tight
      return best;
    }

    function countSpawned(){
      return anchorEl.querySelectorAll(".spawned").length;
    }

    function countCorrectOnScreen(){
      return Array.from(anchorEl.querySelectorAll(".spawned"))
        .filter(el => el.dataset.type === "correct").length;
    }

    // ---------- SPAWN ----------
    function spawnOne(forceType = null){
      const choice =
        forceType === "correct" ? pickRandomCorrect()
        : pickRandomAny();

      const el = document.createElement("a-entity");
      el.classList.add("spawned");
      el.dataset.type = choice.type; // correct/wrong
      el.setAttribute("gltf-model", choice.id);

      // per-model scale
      el.setAttribute("scale", SCALE_BY_ID[choice.id] || "0.25 0.25 0.25");

      // non-overlapping position
      const pos = findNonOverlappingPosition();
      el.setAttribute("position", `${pos.x} ${pos.y} ${Z}`);
      el.setAttribute("rotation", `0 ${rand(0,360)} 0`);

      anchorEl.appendChild(el);
    }

    // Always keep MAX_ON_SCREEN, with at least 2 correct
    function ensureMax(){
      while (countSpawned() < MAX_ON_SCREEN) {
        const remainingSlots = MAX_ON_SCREEN - countSpawned();
        const correctNow = countCorrectOnScreen();
        const needCorrect = Math.max(0, 2 - correctNow);

        // If we are running out of slots and still need correct models, force correct.
        if (needCorrect > 0 && remainingSlots <= needCorrect) {
          spawnOne("correct");
        } else {
          spawnOne(null);
        }
      }

      // Extra safety: if still <2 correct (rare), replace wrong with correct
      while (countCorrectOnScreen() < 2) {
        const wrong = anchorEl.querySelector('.spawned[data-type="wrong"]');
        if (!wrong) break;
        wrong.remove();
        spawnOne("correct");
      }
    }

    // ---------- SCAN FLOW ----------
    anchorEl.addEventListener("targetFound", () => {
      if (!scannedOnce){
        scannedOnce = true;
        introOverlay.style.display = "flex";   // show instructions after first scan
        scanStatus.textContent = "Target detected âœ… Press Start.";
      } else {
        if (!running) scanStatus.textContent = "Target detected âœ… Press Start.";
      }
    });

    anchorEl.addEventListener("targetLost", () => {
      if (!running && scannedOnce){
        scanStatus.textContent = "Target lost â€” bring it back into view to stabilize.";
      }
    });

    // ---------- GAME CONTROL ----------
    function startGame(){
      running = true;
      endOverlay.style.display = "none";
      introOverlay.style.display = "none";

      score = 0;
      timeLeft = GAME_SECONDS;
      updateHud();

      clearModels();
      ensureMax();

      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        if (!running) return;
        timeLeft -= 1;
        updateHud();
        if (timeLeft <= 0) endGame();
      }, 1000);
    }

    function endGame(){
      running = false;
      if (timerId){ clearInterval(timerId); timerId = null; }

      clearModels();
      finalScoreEl.textContent = score;
      endOverlay.style.display = "flex";
    }

    startBtn.addEventListener("click", () => {
      if (!scannedOnce){
        scanStatus.textContent = "Scan the target image first ðŸ™‚";
        introOverlay.style.display = "flex";
        return;
      }
      startGame();
    });

    againBtn.addEventListener("click", () => {
      endOverlay.style.display = "none";
      introOverlay.style.display = "flex";
      scanStatus.textContent = scannedOnce
        ? "Target detected âœ… Press Start."
        : "Scan the target image to beginâ€¦";
      score = 0;
      timeLeft = GAME_SECONDS;
      updateHud();
    });

    // ---------- TAP / HIT TEST ----------
    function meshesUnderAnchor(){
      const meshes = [];
      anchorEl.object3D.traverse(o => { if (o.isMesh) meshes.push(o); });
      return meshes;
    }

    function findSpawnedEntityFromHit(obj3d){
      let o = obj3d;
      while (o && !o.el) o = o.parent;
      if (!o || !o.el) return null;

      let el = o.el;
      while (el && el !== anchorEl && !el.classList.contains("spawned")){
        el = el.parentElement;
      }
      return (el && el.classList && el.classList.contains("spawned")) ? el : null;
    }

    function tapAt(clientX, clientY){
      if (!running) return;
      if (tapLock) return;
      lockTapBriefly();

      if (!sceneEl.canvas || !sceneEl.camera) return;

      const rect = sceneEl.canvas.getBoundingClientRect();
      ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

      raycaster.setFromCamera(ndc, sceneEl.camera);

      const hits = raycaster.intersectObjects(meshesUnderAnchor(), true);
      if (!hits.length) return;

      const hitEl = findSpawnedEntityFromHit(hits[0].object);
      if (!hitEl) return;

      // scoring
      const t = hitEl.dataset.type; // "correct" or "wrong"
      score += (t === "correct") ? 1 : -1;
      updateHud();

      // remove + respawn to keep 4 (and >=2 correct)
      hitEl.remove();
      ensureMax();
    }

    window.addEventListener("touchstart", (e) => {
      if (!e.touches || !e.touches.length) return;
      const t = e.touches[0];
      tapAt(t.clientX, t.clientY);
    }, { passive:true });

    window.addEventListener("mousedown", (e) => {
      tapAt(e.clientX, e.clientY);
    });

    // init HUD
    updateHud();
  </script>
</body>
</html>