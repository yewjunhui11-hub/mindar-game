<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, user-scalable=no" />
  <title>Reduce Single-Use Plastic AR Game</title>

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <!-- nicer font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700;800&display=swap" rel="stylesheet">

  <style>
    body { margin:0; overflow:hidden; font-family: Inter, system-ui, -apple-system, Segoe UI, Arial; }
    canvas, a-scene { touch-action: none; }

    #hud{
      position:fixed; top:12px; left:12px; right:12px;
      display:flex; justify-content:space-between;
      z-index:10; color:#fff; font-weight:800;
      text-shadow:0 2px 10px rgba(0,0,0,0.85);
      pointer-events:none;
      font-size:18px;
    }

    .overlay{
      position:fixed; inset:0; z-index:20;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.65);
      padding:18px;
    }
    .card{
      width:min(560px, 92vw);
      background:rgba(18,18,18,0.92);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:18px;
      padding:16px;
      color:#fff;
      box-shadow:0 18px 45px rgba(0,0,0,0.5);
    }
    h2{ margin:0 0 10px 0; font-size:22px; letter-spacing:-0.2px; }
    p{ margin:0 0 10px 0; line-height:1.45; opacity:0.95; }
    ul{ margin:10px 0 14px 18px; padding:0; line-height:1.55; }
    li{ margin:6px 0; }
    .row{ display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    button{
      padding:12px 14px; border-radius:12px; border:0;
      font-weight:800; cursor:pointer; font-family:inherit;
      background:#fff; color:#111;
    }
    .small{ opacity:0.72; font-size:12px; }
  </style>
</head>

<body>
  <!-- HUD -->
  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Time: <span id="time">30</span>s</div>
  </div>

  <!-- Instruction Overlay (shown after first scan) -->
  <div id="introOverlay" class="overlay" style="display:none;">
    <div class="card">
      <h2>Stop Single-Use Plastic!!</h2>
      <p id="scanStatus" class="small">Scan the target image to beginâ€¦</p>
      <ul>
        <li>You have <b>30 seconds</b>.</li>
        <li>Tap <b>reusable</b> items to get <b>+1</b>.</li>
        <li>Careful not to tap on <b>single-use plastic</b> items or, <b>âˆ’1</b>.</li>
        <li>Good Luck!</li>
      </ul>
      <div class="row">
        <span class="small">Ready?</span>
        <button id="startBtn">Start</button>
      </div>
      <div class="small" style="margin-top:10px;">
        Tip: coming closer helps tracking.
      </div>
    </div>
  </div>

  <!-- End Overlay -->
  <div id="endOverlay" class="overlay" style="display:none;">
    <div class="card">
      <h2>Congrats ðŸŽ‰</h2>
      <p>Your points awarded: <b><span id="finalScore">0</span></b></p>
      <div class="row">
        <span class="small">Play again?</span>
        <button id="againBtn">Again</button>
      </div>
    </div>
  </div>

  <a-scene
    mindar-image="imageTargetSrc: targets.mind; autoStart: true;"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: true"
    renderer="colorManagement: true; physicallyCorrectLights: true"
  >
    <a-assets>
      <a-asset-item id="c1" src="correct_1.glb"></a-asset-item>
      <a-asset-item id="c2" src="correct_2.glb"></a-asset-item>
      <a-asset-item id="c3" src="correct_3.glb"></a-asset-item>

      <a-asset-item id="w1" src="wrong_1.glb"></a-asset-item>
      <a-asset-item id="w2" src="wrong_2.glb"></a-asset-item>
      <a-asset-item id="w3" src="wrong_3.glb"></a-asset-item>
    </a-assets>

    <a-camera id="cam" position="0 0 0" look-controls="enabled: false"></a-camera>

    <!-- Anchor -->
    <a-entity id="anchor" mindar-image-target="targetIndex: 0"></a-entity>
  </a-scene>

  <script>
    // ---------------- CONFIG ----------------
    const GAME_SECONDS = 30;
    const MAX_ON_SCREEN = 4;

    // spawn area (relative to target)
    const SPAWN_X = 0.65;
    const SPAWN_Y = 0.38;
    const Z = 0.05;

    // spacing between models
    const MIN_DISTANCE = 0.25;

    // spawn timing
    const SPAWN_INTERVAL_MS = 500;   // one-by-one spawn
    const MODEL_LIFETIME_MS = 2000;  // disappear after 2s if not tapped
    const QUICK_RESPAWN_MS = 80;     // when tapped, refill quickly (still "one-by-one")

    // Per-model scale (your values)
    const SCALE_BY_ID = {
      "#c1": "0.95 0.95 0.95", // Metal bottle model
      "#c2": "0.04 0.04 0.04", // Container model
      "#c3": "10.25 10.25 10.25",
      "#w1": "1.80 1.80 1.80", // Plastic cup 
      "#w2": "1.50 1.50 1.50", // Plastic fork
      "#w3": "1.80 1.80 1.80", // Plastic straw
    };

    const MODEL_POOL = [
      { id: "#c1", type: "correct" },
      { id: "#c2", type: "correct" },
      { id: "#c3", type: "correct" },
      { id: "#w1", type: "wrong"   },
      { id: "#w2", type: "wrong"   },
      { id: "#w3", type: "wrong"   },
    ];

    // ---------------- STATE ----------------
    const sceneEl = document.querySelector("a-scene");
    const anchorEl = document.getElementById("anchor");

    const introOverlay = document.getElementById("introOverlay");
    const endOverlay = document.getElementById("endOverlay");
    const startBtn = document.getElementById("startBtn");
    const againBtn = document.getElementById("againBtn");

    const scanStatus = document.getElementById("scanStatus");
    const scoreEl = document.getElementById("score");
    const timeEl = document.getElementById("time");
    const finalScoreEl = document.getElementById("finalScore");

    let scannedOnce = false;
    let running = false;
    let score = 0;
    let timeLeft = GAME_SECONDS;
    let timerId = null;

    // manual raycast for reliable tapping
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    let tapLock = false;

    // Spawn scheduling state
    let pendingSpawns = 0;
    let pendingCorrect = 0;
    const lifetimeTimers = new WeakMap(); // entity -> timerId

    function rand(min, max){ return Math.random() * (max - min) + min; }

    function lockTapBriefly(){
      tapLock = true;
      setTimeout(() => tapLock = false, 220);
    }

    function updateHud(){
      scoreEl.textContent = score;
      timeEl.textContent = timeLeft;
    }

    function clearAllScheduled(){
      pendingSpawns = 0;
      pendingCorrect = 0;
    }

    function clearModels(){
      anchorEl.querySelectorAll(".spawned").forEach(el => {
        const tid = lifetimeTimers.get(el);
        if (tid) clearTimeout(tid);
        el.remove();
      });
      clearAllScheduled();
    }

    // ---------- PICKERS ----------
    function pickRandomFrom(list){
      return list[Math.floor(Math.random() * list.length)];
    }
    function pickRandomCorrect(){
      return pickRandomFrom(MODEL_POOL.filter(m => m.type === "correct"));
    }
    function pickRandomAny(){
      return pickRandomFrom(MODEL_POOL);
    }

    // ---------- SPACING ----------
    function getSpawnedPositions(){
      return Array.from(anchorEl.querySelectorAll(".spawned")).map(el => {
        const p = el.getAttribute("position");
        return { x: parseFloat(p.x), y: parseFloat(p.y) };
      });
    }

    function distance(a, b){
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function findNonOverlappingPosition(){
      const existing = getSpawnedPositions();
      let best = { x: 0, y: 0 };

      for (let attempt = 0; attempt < 25; attempt++){
        const candidate = { x: rand(-SPAWN_X, SPAWN_X), y: rand(-SPAWN_Y, SPAWN_Y) };
        best = candidate;
        const ok = existing.every(p => distance(candidate, p) >= MIN_DISTANCE);
        if (ok) return candidate;
      }
      return best;
    }

    function countSpawned(){
      return anchorEl.querySelectorAll(".spawned").length;
    }

    function countCorrectOnScreen(){
      return Array.from(anchorEl.querySelectorAll(".spawned"))
        .filter(el => el.dataset.type === "correct").length;
    }

    // ---------- SPAWN (creates entity + lifetime auto-remove) ----------
    function spawnOneNow(forceType = null){
      if (!running) return;

      const choice = (forceType === "correct") ? pickRandomCorrect() : pickRandomAny();

      const el = document.createElement("a-entity");
      el.classList.add("spawned");
      el.dataset.type = choice.type;
      el.setAttribute("gltf-model", choice.id);
      el.setAttribute("scale", SCALE_BY_ID[choice.id] || "1 1 1");

      const pos = findNonOverlappingPosition();
      el.setAttribute("position", `${pos.x} ${pos.y} ${Z}`);
      el.setAttribute("rotation", `0 ${rand(0,360)} 0`);

      anchorEl.appendChild(el);

      // Auto-remove if not tapped within 2 seconds
      const tid = setTimeout(() => {
        if (!running) return;
        if (!el.isConnected) return;

        removeEntity(el);
        // Refill (one-by-one)
        scheduleFill(SPAWN_INTERVAL_MS);
      }, MODEL_LIFETIME_MS);

      lifetimeTimers.set(el, tid);
    }

    function removeEntity(el){
      const tid = lifetimeTimers.get(el);
      if (tid) clearTimeout(tid);
      lifetimeTimers.delete(el);
      if (el.isConnected) el.remove();
    }

    // ---------- ONE-BY-ONE FILL SCHEDULER ----------
    function scheduleSpawn(forceType, delayMs){
      pendingSpawns += 1;
      if (forceType === "correct") pendingCorrect += 1;

      setTimeout(() => {
        // this spawn is happening now
        pendingSpawns -= 1;
        if (forceType === "correct") pendingCorrect -= 1;

        spawnOneNow(forceType);
      }, delayMs);
    }

    // Fill up to MAX_ON_SCREEN, spawning one-by-one. Guarantee >=2 correct.
    function scheduleFill(baseDelay = 0){
      if (!running) return;

      const currentTotal = countSpawned();
      const deficit = MAX_ON_SCREEN - (currentTotal + pendingSpawns);
      if (deficit <= 0) return;

      // Project counts including already scheduled spawns
      let projectedCorrect = countCorrectOnScreen() + pendingCorrect;

      for (let i = 0; i < deficit; i++){
        // Guarantee at least 2 correct: force correct until we reach 2.
        const forceType = (projectedCorrect < 2) ? "correct" : null;
        if (forceType === "correct") projectedCorrect += 1;

        const delay = baseDelay + i * SPAWN_INTERVAL_MS;
        scheduleSpawn(forceType, delay);
      }
    }

    // ---------- SCAN FLOW ----------
    anchorEl.addEventListener("targetFound", () => {
      if (!scannedOnce){
        scannedOnce = true;
        introOverlay.style.display = "flex";
        scanStatus.textContent = "Target detected âœ… Press Start.";
      } else {
        if (!running) scanStatus.textContent = "Target detected âœ… Press Start.";
      }
    });

    anchorEl.addEventListener("targetLost", () => {
      if (!running && scannedOnce){
        scanStatus.textContent = "Target lost â€” bring it back into view to stabilize.";
      }
    });

    // ---------- GAME CONTROL ----------
    function startGame(){
      running = true;
      endOverlay.style.display = "none";
      introOverlay.style.display = "none";

      score = 0;
      timeLeft = GAME_SECONDS;
      updateHud();

      clearModels();
      // spawn 4 one-by-one at start
      scheduleFill(0);

      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        if (!running) return;
        timeLeft -= 1;
        updateHud();
        if (timeLeft <= 0) endGame();
      }, 1000);
    }

    function endGame(){
      running = false;
      if (timerId){ clearInterval(timerId); timerId = null; }

      clearModels();
      finalScoreEl.textContent = score;
      endOverlay.style.display = "flex";
    }

    startBtn.addEventListener("click", () => {
      if (!scannedOnce){
        scanStatus.textContent = "Scan the target image first ðŸ™‚";
        introOverlay.style.display = "flex";
        return;
      }
      startGame();
    });

    againBtn.addEventListener("click", () => {
      endOverlay.style.display = "none";
      introOverlay.style.display = "flex";
      scanStatus.textContent = scannedOnce
        ? "Target detected âœ… Press Start."
        : "Scan the target image to beginâ€¦";
      score = 0;
      timeLeft = GAME_SECONDS;
      updateHud();
    });

    // ---------- TAP / HIT TEST ----------
    function meshesUnderAnchor(){
      const meshes = [];
      anchorEl.object3D.traverse(o => { if (o.isMesh) meshes.push(o); });
      return meshes;
    }

    function findSpawnedEntityFromHit(obj3d){
      let o = obj3d;
      while (o && !o.el) o = o.parent;
      if (!o || !o.el) return null;

      let el = o.el;
      while (el && el !== anchorEl && !el.classList.contains("spawned")){
        el = el.parentElement;
      }
      return (el && el.classList && el.classList.contains("spawned")) ? el : null;
    }

    function tapAt(clientX, clientY){
      if (!running) return;
      if (tapLock) return;
      lockTapBriefly();

      if (!sceneEl.canvas || !sceneEl.camera) return;

      const rect = sceneEl.canvas.getBoundingClientRect();
      ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      ndc.y = -(((clientY - rect.top) / rect.height) * 2 - 1);

      raycaster.setFromCamera(ndc, sceneEl.camera);

      const hits = raycaster.intersectObjects(meshesUnderAnchor(), true);
      if (!hits.length) return;

      const hitEl = findSpawnedEntityFromHit(hits[0].object);
      if (!hitEl) return;

      // scoring
      const t = hitEl.dataset.type; // correct / wrong
      score += (t === "correct") ? 1 : -1;
      updateHud();

      // remove clicked model
      removeEntity(hitEl);

      // refill quickly (but still one-by-one style)
      scheduleFill(QUICK_RESPAWN_MS);
    }

    window.addEventListener("touchstart", (e) => {
      if (!e.touches || !e.touches.length) return;
      const t = e.touches[0];
      tapAt(t.clientX, t.clientY);
    }, { passive:true });

    window.addEventListener("mousedown", (e) => {
      tapAt(e.clientX, e.clientY);
    });

    // init HUD
    updateHud();
  </script>
</body>
</html>